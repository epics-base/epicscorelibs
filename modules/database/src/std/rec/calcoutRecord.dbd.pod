#*************************************************************************
# Copyright (c) 2007 UChicago Argonne LLC, as Operator of Argonne
#     National Laboratory.
# Copyright (c) 2002 The Regents of the University of California, as
#     Operator of Los Alamos National Laboratory.
# EPICS BASE is distributed subject to a Software License Agreement found
# in file LICENSE that is included with this distribution.
#*************************************************************************

=title Calculation Output Record (calcout)

The Calculation Output or "Calcout" record is similar to the Calc record
with the added feature of having outputs (an "output link" and an "output
event") which are conditionally executed based on the result of the
calculation. This feature allows conditional branching to be implemented
within an EPICS database (e.g. process Record_A only if Record_B has a
value of 0). The Calcout record is also similar to the Wait record (with
additional features) but uses EPICS standard INLINK and OUTLINK fields
rather than the DBF_STRING fields used in the Wait record. For new
databases, it is recommended that the Calcout record be used instead of the
Wait record.

Since 7.0.10 the number of inputs has been increased from 12 to 21.

=head2 Parameter Fields

The record-specific fields are described below, grouped by functionality.

=recordtype calcout

=cut

menu(calcoutOOPT) {
	choice(calcoutOOPT_Every_Time,"Every Time")
	choice(calcoutOOPT_On_Change,"On Change")
	choice(calcoutOOPT_When_Zero,"When Zero")
	choice(calcoutOOPT_When_Non_zero,"When Non-zero")
	choice(calcoutOOPT_Transition_To_Zero,"Transition To Zero")
	choice(calcoutOOPT_Transition_To_Non_zero,"Transition To Non-zero")
}
menu(calcoutDOPT) {
	choice(calcoutDOPT_Use_VAL,"Use CALC")
	choice(calcoutDOPT_Use_OVAL,"Use OCAL")
}
menu(calcoutINAV) {
	choice(calcoutINAV_EXT_NC,"Ext PV NC")
	choice(calcoutINAV_EXT,"Ext PV OK")
	choice(calcoutINAV_LOC,"Local PV")
	choice(calcoutINAV_CON,"Constant")
}

recordtype(calcout) {

=head3 Scan Parameters

The Calcout record has the standard fields for specifying under what
circumstances the record will be processed.
These fields are listed in L<Scan Fields|dbCommonRecord/Scan Fields>.

=head3 Read Parameters

The read parameters for the Calcout record consists of 21 input links INPA -
INPU. The fields can be database links, channel access links, or constants.
If they are links, they must specify another record's field. If
they are constants, they will be initialized with the value they are
configured with and can be changed via C<dbPuts>. These fields cannot be
hardware addresses. In addition, the Calcout record contains the INAV -
INUV fields which indicate the status of the link fields, for
example, whether or not the specified PV was found and a link to it
established. See L<Operator Display Parameters> for an explanation of these
fields.

=fields INPA - INPU

=head3 Expressions

Like the Calc record, the Calcout record's CALC field holds an infix expression
to be evaluated whenever the record is processed.
The resulting value is placed in the VAL field.

The OOPT field condition is applied to VAL (see L<Output Parameters>) and
controls whether to write to the output link (or post a named event), and the
DOPT field selects whether VAL should be written, or another expression from
the OCAL field should be evaluated and used instead.

The CALC and OCAL expressions get compiled into streams of Reverse Polish
Notation (RPN) opcodes for a stack-based machine, and stored in the RPCL and
ORPC fields respectively.

The RPN opcodes are used to calculate VAL at run-time, and are more efficient
than evaluating the infix expression.
The CALC and OCAL expressions can be replaced at run-time, triggering a special
record routine to compile the new expression into Reverse Polish Notation.

The infix expressions that can be used are very similar to the C expression
syntax, but with some additions and subtle differences in operator meaning and
precedence.
The string may contain a series of expressions separated by a semi-colon
character C<;>, any one of which may provide the calculation result.
All other expressions included in the string must assign their result to a
variable.
All alphabetic elements described below are case independent, so upper and lower
case letters may be used and mixed in the variable and function names as
desired.
Spaces may be used anywhere within an expression except between characters that
make up a single expression element.

The range of expressions supported by the calculation record are separated into
literals, constants, operands, algebraic operators, trigonometric operators,
relational operators, logical operators, the assignment operator, parentheses
and commas, and the question mark colon or C<?:> operator.

=fields CALC, VAL, OVAL, RPCL, ORPC

=head3 Literals

=over 1

=item *
Standard double precision floating point numbers

=item *
C<Inf>: Infinity

=item *
C<NaN>: Not a Number

=back

=head3 Constants

=over

=item *
C<PI>: returns the mathematical constant E<pi>

=item *
C<D2R>: evaluates to E<pi>/180 which, when used as a multiplier, converts an
angle from degrees to radians

=item *
C<R2D>: evaluates to 180/E<pi> which, when used as a multiplier, converts an
angle from radians to degrees

=back

=head3 Operands

The expression can use the values retrieved from the INPx links as
operands, though constants can be used as operands too. These values
retrieved from the input links are stored in the A-U fields. The values to
be used in the expression are simple references by the field letter. For
instance, the value obtained from the INPA link is stored in field A, and
the values obtained from the INPB link is stored in the field B. The names
can be included in the expression will operate on their respective values,
as in A+B.

=fields A - U

The keyword VAL returns the current contents of the expression's result
field, i.e. the VAL field for the CALC expression and the OVAL field for
the OCAL expression. (These fields can be written to by CA put, so it might
I<not> be the result from the last time the expression was evaluated).

=head3 Arithmetic Operators

Except for unary minus these are infix binary operators.

=over 1

=item *
C<+> : Addition

=item *
C<-> : Subtraction

=item *
C<-> : Minus (unary)

=item *
C<*> : Multiplication

=item *
C</> : Division

=item *
C<%> : Modulo

=item *
C<^> : Exponential

=item *
C<**> : Exponential

=back

=head3 Algebraic Functions

When functions take more than one argument, a comma separator must appear
between them.

=over 1

=item *
C<ABS (arg)> : Absolute value

=item *
C<EXP (arg)> : Exponential function

=item *
C<FMOD (num, den)> : Floating point modulo. Added in 7.0.8

=item *
C<LN (arg)> : Natural log

=item *
C<LOG (arg)> : Log base 10

=item *
C<LOGE (arg)> : Natural log

=item *
C<MIN (any number of args)> : Minimum

=item *
C<MAX (any number of args)> : Maximum

=item *
C<SQR (arg)> : Square root

=item *
C<SQRT (arg)> : Square root

=back

=head3 Trigonometric Functions

=over 1

=item *
C<SIN (arg)> : Sine

=item *
C<ASIN (arg)> : Arc sine

=item *
C<COS (arg)> : Cosine

=item *
C<ACOS (arg)> : Arc cosine

=item *
C<TAN (arg)> : Tangent

=item *
C<ATAN (arg)> : Arc tangent

=item *
C<ATAN2 (den, num)> : 2-parameter Arc tangent. Arg's are reversed to ANSI C

=back

=head3 Hyperbolic Trigonometry Functions

=over 1

=item *
C<SINH (arg)> : Hyperbolic sine

=item *
C<COSH (arg)> : Hyperbolic cosine

=item *
C<TANH (arg)> : Hyperbolic tangent

=back

=head3 Numeric Functions

=over 1

=item *
C<CEIL (arg)> : Ceiling

=item *
C<FLOOR (arg)> : Floor

=item *
C<NINT (arg)> : Round to nearest integer

=item *
C<ISINF (arg)> : returns non-zero if any argument is Inf

=item *
C<ISNAN (any number of args)> : returns non-zero (true) if any argument is NaN
or Inf

=item *
C<FINITE (any number of args)> : returns non-zero (true) if none of the
arguments are NaN or Inf

=back

=head3 Boolean/Logical Operators

These operators use their arguments as a true (non-zero) or false (zero) value.

=over 1

=item *
C<&&> : And, infix binary

=item *
C<||> : Or, infix binary

=item *
C<!> : Not, unary prefix

=back

=head3 Bitwise Operators

Mostly infix binary, the arguments are converted to a 32-bit integer, the
operator is applied, and the result converted back into a double.

=over 1

=item *
C<&> : Bitwise and

=item *
C<|> : Bitwise or

=item *
C<~> : Bitwise not or one's complement, unary prefix

=item *
C<<< << >>> : Arithmetic shift left

=item *
C<<< >> >>> : Arithmetic shift right

=item *
C<<<< >>> >>>> : Logical shift right

=item *
C<AND> : Bitwise and

=item *
C<OR> : Bitwise or

=item *
C<XOR> : Bitwise exclusive or

=item *
C<NOT> : Bitwise not or one's complement, unary prefix

=back

=head3 Relational Operators

These are all infix binary operators.

=over 1

=item *
C<<< >= >>> : Greater than or equal to

=item *
C<<< > >>> : Greater than

=item *
C<<< <= >>> : Less than or equal to

=item *
C<<< < >>> : Less than

=item *
C<<< != >>> : Not equal to

=item *
C<<< # >>> : Not equal to

=item *
C<<< == >>> : Equal to

=item *
C<<< = >>> : Equal to (not assignment)

=back

=head3 Assignment Operator

=over 1

=item *
C<:=> : assigns a value (right hand side) to a variable (i.e. field)

=back

=head3 Parentheses, Comma, and Semicolon

The open C<(> and close parentheses C<)> are supported to override precedence
rules in a sub-expression.
Nested parentheses are supported to significant depth.

The comma C<,> is required to separate the arguments of a function.

The semicolon C<;> is used to value separate expressions.
Exactly one value expression must be present, but multiple assignment
expressions may be included before and/or after the value expression.

=head3 Conditional Operator

The C language's question mark colon C<?:> ternary operator is supported.
The format is:

I<condition> C<?> I<true-expression> C<:> I<false-expression>

=head2 Expression Examples

=head3 Algebraic

C<A + B + 10>

=over 1

=item *
Result is C<A + B + 10>

=back

=head3 Relational

C<<< (A + B) < (C + D) >>>

=over 1

=item *
Result is 1 if C<<< (A + B) < (C + D) >>>

=item *
Result is 0 if C<<< (A + B) >= (C + D) >>>

=back

=head3 Question Mark

C<<< (A + B) < (C + D) ? E : F + L + 10 >>>

=over 1

=item *
Result is C<E> if C<<< (A + B) < (C + D) >>>

=item *
Result is C<F + L + 10> if C<<< (A + B) >= (C + D) >>>

=back

Prior to Base 3.14.9 it was legal to omit the colon C<:> and the second (else)
part of the conditional, like this:

C<<< (A + B)<(C + D) ? E >>>

=over 1

=item *
Result is E if C<<< (A + B)<(C + D) >>>

=item *
Result is unchanged if C<<< (A + B)>=(C + D) >>>

From 3.14.9 onwards, this expression must be written as
C<<< (A + B) < (C + D) ? E : VAL >>>

=back

=head3 Logical

C<A & B>

=over 1

=item *
Causes the following to occur:

=over 1

=item *
Convert A to integer

=item *
Convert B to integer

=item *
Bitwise A C<and> B

=item *
Convert result to floating point

=back

=back

=head3 Assignment

C<sin(a); a:=a+D2R>

=over 1

=item *
Causes the Calc record to output the successive values of a sine curve in
1 degree intervals.

=back

=head3 Output Parameters

These parameters specify and control the output capabilities of the Calcout
record. They determine when to write the output, where to write it, and what
the output will be. The OUT link specifies the Process Variable to which
the result will be written.

=head4 Menu calcoutOOPT

The OOPT field determines the condition that causes the output link to be
written to. It's a menu field that has six choices:

=menu calcoutOOPT

=over

=item *
C<Every Time> -- write output every time record is processed.

=item *
C<On Change> -- write output every time VAL changes, i.e., every time the
result of the expression changes.

=item *
C<When Zero> -- when record is processed, write output if VAL is zero.

=item *
C<When Non-zero> -- when record is processed, write output if VAL is
non-zero.

=item *
C<Transition To Zero> -- when record is processed, write output only if VAL
is zero and the last value was non-zero.

=item *
C<Transition To Non-zero> -- when record is processed, write output only if
VAL is non-zero and last value was zero.

=back

=head4 Menu calcoutDOPT

The DOPT field determines what data is written to the output link when the
output is executed. The field is a menu field with two options: 

=menu calcoutDOPT

If C<Use CALC> is specified, when the record writes its
output it will write the result of the expression in the CALC field, that
is, it will write the value of the VAL field. If C<Use OCAL> is specified,
the record will instead write the result of the expression in the OCAL
field, which is contained in the OVAL field. The OCAL field is exactly like
the CALC field and has the same functionality it can contain the string
representation of an expression which is evaluated at run-time. Thus, if
necessary, the record can use the result of the CALC expression to
determine if data should be written and can use the result of the OCAL
expression as the data to write.

If the OEVT field isn't empty and the condition in the OOPT field is met, the
record will post the corresponding named event.
If the ODLY field is non-zero, the record pauses for the specified number of
seconds before executing the OUT link or posting the output event.
During this waiting period the record is "active" and will not be processed
again until the wait is over.
The field DLYA is equal to 1 during the delay period. The resolution of the
delay entry system dependent.

The IVOA field specifies what action to take with the OUT link if the
Calcout record enters an INVALID alarm status. The options are
C<Continue normally>, C<Don't drive outputs>, and C<Set output to IVOV>.
If the IVOA field is C<Set output to IVOV>, the data entered into the
IVOV field is written to the OUT link if the record alarm severity is
INVALID.

=fields OUT, OOPT, DOPT, OCAL, OVAL, OEVT, ODLY, IVOA, IVOV

=head3 Operator Display Parameter

These parameters are used to present meaningful data to the operator. Some
are also meant to represent the status of the record at run-time.

The EGU field contains a string of up to 16 characters which is supplied by
the user and which describes the values being operated upon. The string is
retrieved whenever the routine C<get_units()> is called. The EGU string is
solely for an operator's sake and does not have to be used.

The HOPR and LOPR fields only refer to the limits of the VAL, HIHI, HIGH,
LOW, and LOLO fields. PREC controls the precision of the VAL field.

=head4 Menu calcoutINAV

The INAV-INUV fields indicate the status of the link to the PVs specified
in the INPA-INPU fields respectively. These fields can have four possible
values:

=menu calcoutINAV

=over 1

=item *
C<Ext PV NC> -- the PV wasn't found on this IOC and a Channel Access link
hasn't been established.

=item *
C<Ext PV OK> -- the PV wasn't found on this IOC and a Channel Access link
has been established.

=item *
C<Local PV> -- the PV was found on this IOC.

=item *
C<Constant> -- the corresponding link field is a constant.

=back

The OUTV field indicates the status of the OUT link. If has the same
possible values as the INAV-INUV fields.

The CLCV and OLCV fields indicate the validity of the expression in the
CALC and OCAL fields respectively. If the expression in invalid, the field
is set to one.

The DLYA field is set to one during the delay specified in ODLY.

See L<Fields Common to All Record Types|dbCommonRecord/Operator Display
Parameters> for more on the record name (NAME) and description (DESC) fields.

=fields EGU, PREC, HOPR, LOPR, INAV - INUV, OUTV, CLCV, OCLV, DLYA, NAME, DESC

=head3 Alarm Parameters

The possible alarm conditions for the Calcout record are the SCAN, READ,
Calculation, and limit alarms. The SCAN and READ alarms are called by the
record support routines. The Calculation alarm is called by the record
processing routine when the CALC expression is an invalid one, upon which
an error message is generated.

The following alarm parameters, which are configured by the user, define the
limit alarms for the VAL field and the severity corresponding to those
conditions.

The HYST field defines an alarm deadband for each limit.

See L<Alarm Specification|https://docs.epics-controls.org/en/latest/process-database/EPICS_Process_Database_Concepts.html#alarm-specification>
for a complete explanation of record alarms and of the standard fields.
L<Alarm Fields|dbCommonRecord/Alarm Fields> lists other fields related
to alarms that are common to all record types.

=fields HIHI, HIGH, LOW, LOLO, HHSV, HSV, LSV, LLSV, HYST

=head3 Monitor Parameters

These parameters are used to determine when to send monitors for the value
fields. These monitors are sent when the value field exceeds the last
monitored field by the appropriate deadband, the ADEL for archiver monitors
and the MDEL field for all other types of monitors. If these fields have a
value of zero, every time the value changes, monitors are triggered; if
they have a value of -1, every time the record is scanned, monitors are
triggered. See L<Monitor Specification> for a complete explanation of
monitors.

=fields ADEL, MDEL

=head3 Run-time Parameters

These fields are not configurable using a configuration tool and none are
modifiable at run-time. They are used to process the record.

The LALM field is used to implement the hysteresis factor for the alarm
limits.

The LA-LU fields are used to decide when to trigger monitors for the
corresponding fields. For instance, if LA does not equal the value for A,
monitors for A are triggered. The MLST and ALST fields are used in the same
manner for the VAL field.

=fields LALM, ALST, MLST, LA - LU

=cut

	include "dbCommon.dbd" 
    %/* Declare Device Support Entry Table */
    %struct calcoutRecord;
    %typedef struct calcoutdset {
    %    dset common;
    %    long (*write)(struct calcoutRecord *prec);
    %} calcoutdset;
    %#define HAS_calcoutdset
    %
	field(RPVT,DBF_NOACCESS) {
		prompt("Record Private")
		special(SPC_NOMOD)
		interest(4)
		extra("struct rpvtStruct *rpvt")
	}
	field(VAL,DBF_DOUBLE) {
		prompt("Result")
		promptgroup("50 - Output")
		asl(ASL0)
	}
	field(PVAL,DBF_DOUBLE) {
		prompt("Previous Value")
	}
	field(CALC,DBF_STRING) {
		prompt("Calculation")
		promptgroup("30 - Action")
		special(SPC_CALC)
		pp(TRUE)
		size(160)
		initial("0")
	}
	field(CLCV,DBF_LONG) {
		prompt("CALC Valid")
		interest(1)
	}
	field(INPA,DBF_INLINK) {
		prompt("Input A")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPB,DBF_INLINK) {
		prompt("Input B")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPC,DBF_INLINK) {
		prompt("Input C")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPD,DBF_INLINK) {
		prompt("Input D")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPE,DBF_INLINK) {
		prompt("Input E")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPF,DBF_INLINK) {
		prompt("Input F")
		special(SPC_MOD)
		promptgroup("41 - Input A-F")
		interest(1)
	}
	field(INPG,DBF_INLINK) {
		prompt("Input G")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPH,DBF_INLINK) {
		prompt("Input H")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPI,DBF_INLINK) {
		prompt("Input I")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPJ,DBF_INLINK) {
		prompt("Input J")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPK,DBF_INLINK) {
		prompt("Input K")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPL,DBF_INLINK) {
		prompt("Input L")
		special(SPC_MOD)
		promptgroup("42 - Input G-L")
		interest(1)
	}
	field(INPM,DBF_INLINK) {
		prompt("Input M")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPN,DBF_INLINK) {
		prompt("Input N")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPO,DBF_INLINK) {
		prompt("Input O")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPP,DBF_INLINK) {
		prompt("Input P")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPQ,DBF_INLINK) {
		prompt("Input Q")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPR,DBF_INLINK) {
		prompt("Input R")
		special(SPC_MOD)
		promptgroup("43 - Input M-R")
		interest(1)
	}
	field(INPS,DBF_INLINK) {
		prompt("Input S")
		special(SPC_MOD)
		promptgroup("44 - Input S-U")
		interest(1)
	}
	field(INPT,DBF_INLINK) {
		prompt("Input T")
		special(SPC_MOD)
		promptgroup("44 - Input S-U")
		interest(1)
	}
	field(INPU,DBF_INLINK) {
		prompt("Input U")
		special(SPC_MOD)
		promptgroup("44 - Input S-U")
		interest(1)
	}
	field(OUT,DBF_OUTLINK) {
		prompt("Output Specification")
		special(SPC_MOD)
		promptgroup("50 - Output")
		interest(1)
	}
	field(INAV,DBF_MENU) {
		prompt("INPA PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INBV,DBF_MENU) {
		prompt("INPB PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INCV,DBF_MENU) {
		prompt("INPC PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INDV,DBF_MENU) {
		prompt("INPD PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INEV,DBF_MENU) {
		prompt("INPE PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INFV,DBF_MENU) {
		prompt("INPF PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INGV,DBF_MENU) {
		prompt("INPG PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INHV,DBF_MENU) {
		prompt("INPH PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INIV,DBF_MENU) {
		prompt("INPI PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INJV,DBF_MENU) {
		prompt("INPJ PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INKV,DBF_MENU) {
		prompt("INPK PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INLV,DBF_MENU) {
		prompt("INPL PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INMV,DBF_MENU) {
		prompt("INPM PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INNV,DBF_MENU) {
		prompt("INPN PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INOV,DBF_MENU) {
		prompt("INPO PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INPV,DBF_MENU) {
		prompt("INPP PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INQV,DBF_MENU) {
		prompt("INPQ PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INRV,DBF_MENU) {
		prompt("INPR PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INSV,DBF_MENU) {
		prompt("INPS PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INTV,DBF_MENU) {
		prompt("INPT PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(INUV,DBF_MENU) {
		prompt("INPU PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
		initial("1")
	}
	field(OUTV,DBF_MENU) {
		prompt("OUT PV Status")
		special(SPC_NOMOD)
		interest(1)
		menu(calcoutINAV)
	}
	field(OOPT,DBF_MENU) {
		prompt("Output Execute Opt")
		promptgroup("50 - Output")
		interest(1)
		menu(calcoutOOPT)
	}
	field(ODLY,DBF_DOUBLE) {
		prompt("Output Execute Delay")
		promptgroup("50 - Output")
		asl(ASL0)
		interest(1)
	}
	field(DLYA,DBF_USHORT) {
		prompt("Output Delay Active")
		special(SPC_NOMOD)
		asl(ASL0)
	}
	field(DOPT,DBF_MENU) {
		prompt("Output Data Opt")
		promptgroup("30 - Action")
		interest(1)
		menu(calcoutDOPT)
	}
	field(OCAL,DBF_STRING) {
		prompt("Output Calculation")
		promptgroup("30 - Action")
		special(SPC_CALC)
		pp(TRUE)
		size(160)
		initial("0")
	}
	field(OCLV,DBF_LONG) {
		prompt("OCAL Valid")
		interest(1)
	}
	field(OEVT,DBF_STRING) {
		prompt("Event To Issue")
		promptgroup("30 - Action")
		special(SPC_MOD)
		asl(ASL0)
		size(40)
	}
	%#include "dbScan.h"
	field(EPVT, DBF_NOACCESS) {
		prompt("Event private")
		special(SPC_NOMOD)
		interest(4)
		extra("EVENTPVT epvt")
	}
	field(IVOA,DBF_MENU) {
		prompt("INVALID output action")
		promptgroup("50 - Output")
		interest(2)
		menu(menuIvoa)
	}
	field(IVOV,DBF_DOUBLE) {
		prompt("INVALID output value")
		promptgroup("50 - Output")
		interest(2)
	}
	field(EGU,DBF_STRING) {
		prompt("Engineering Units")
		promptgroup("80 - Display")
		interest(1)
		size(16)
		prop(YES)		# get_units
	}
	field(PREC,DBF_SHORT) {
		prompt("Display Precision")
		promptgroup("80 - Display")
		interest(1)
		prop(YES)		# get_precision
	}
	field(HOPR,DBF_DOUBLE) {
		prompt("High Operating Rng")
		promptgroup("80 - Display")
		interest(1)
		prop(YES)		# get_graphic_double, get_control_double
	}
	field(LOPR,DBF_DOUBLE) {
		prompt("Low Operating Range")
		promptgroup("80 - Display")
		interest(1)
		prop(YES)		# get_graphic_double, get_control_double
	}
	field(HIHI,DBF_DOUBLE) {
		prompt("Hihi Alarm Limit")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
	}
	field(LOLO,DBF_DOUBLE) {
		prompt("Lolo Alarm Limit")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
	}
	field(HIGH,DBF_DOUBLE) {
		prompt("High Alarm Limit")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
	}
	field(LOW,DBF_DOUBLE) {
		prompt("Low Alarm Limit")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
	}
	field(HHSV,DBF_MENU) {
		prompt("Hihi Severity")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
		menu(menuAlarmSevr)
	}
	field(LLSV,DBF_MENU) {
		prompt("Lolo Severity")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
		menu(menuAlarmSevr)
	}
	field(HSV,DBF_MENU) {
		prompt("High Severity")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
		menu(menuAlarmSevr)
	}
	field(LSV,DBF_MENU) {
		prompt("Low Severity")
		promptgroup("70 - Alarm")
		pp(TRUE)
		interest(1)
		prop(YES)		# get_alarm_double
		menu(menuAlarmSevr)
	}
	field(HYST,DBF_DOUBLE) {
		prompt("Alarm Deadband")
		promptgroup("70 - Alarm")
		interest(1)
	}
	field(ADEL,DBF_DOUBLE) {
		prompt("Archive Deadband")
		promptgroup("80 - Display")
		interest(1)
	}
	field(MDEL,DBF_DOUBLE) {
		prompt("Monitor Deadband")
		promptgroup("80 - Display")
		interest(1)
	}
	field(A,DBF_DOUBLE) {
		prompt("Value of Input A")
		pp(TRUE)
	}
	field(B,DBF_DOUBLE) {
		prompt("Value of Input B")
		pp(TRUE)
	}
	field(C,DBF_DOUBLE) {
		prompt("Value of Input C")
		pp(TRUE)
	}
	field(D,DBF_DOUBLE) {
		prompt("Value of Input D")
		pp(TRUE)
	}
	field(E,DBF_DOUBLE) {
		prompt("Value of Input E")
		pp(TRUE)
	}
	field(F,DBF_DOUBLE) {
		prompt("Value of Input F")
		pp(TRUE)
	}
	field(G,DBF_DOUBLE) {
		prompt("Value of Input G")
		pp(TRUE)
	}
	field(H,DBF_DOUBLE) {
		prompt("Value of Input H")
		pp(TRUE)
	}
	field(I,DBF_DOUBLE) {
		prompt("Value of Input I")
		pp(TRUE)
	}
	field(J,DBF_DOUBLE) {
		prompt("Value of Input J")
		pp(TRUE)
	}
	field(K,DBF_DOUBLE) {
		prompt("Value of Input K")
		pp(TRUE)
	}
	field(L,DBF_DOUBLE) {
		prompt("Value of Input L")
		pp(TRUE)
	}
	field(M,DBF_DOUBLE) {
		prompt("Value of Input M")
		pp(TRUE)
	}
	field(N,DBF_DOUBLE) {
		prompt("Value of Input N")
		pp(TRUE)
	}
	field(O,DBF_DOUBLE) {
		prompt("Value of Input O")
		pp(TRUE)
	}
	field(P,DBF_DOUBLE) {
		prompt("Value of Input P")
		pp(TRUE)
	}
	field(Q,DBF_DOUBLE) {
		prompt("Value of Input Q")
		pp(TRUE)
	}
	field(R,DBF_DOUBLE) {
		prompt("Value of Input R")
		pp(TRUE)
	}
	field(S,DBF_DOUBLE) {
		prompt("Value of Input S")
		pp(TRUE)
	}
	field(T,DBF_DOUBLE) {
		prompt("Value of Input T")
		pp(TRUE)
	}
	field(U,DBF_DOUBLE) {
		prompt("Value of Input U")
		pp(TRUE)
	}
	field(OVAL,DBF_DOUBLE) {
		prompt("Output Value")
		asl(ASL0)
	}
	field(LA,DBF_DOUBLE) {
		prompt("Prev Value of A")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LB,DBF_DOUBLE) {
		prompt("Prev Value of B")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LC,DBF_DOUBLE) {
		prompt("Prev Value of C")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LD,DBF_DOUBLE) {
		prompt("Prev Value of D")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LE,DBF_DOUBLE) {
		prompt("Prev Value of E")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LF,DBF_DOUBLE) {
		prompt("Prev Value of F")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LG,DBF_DOUBLE) {
		prompt("Prev Value of G")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LH,DBF_DOUBLE) {
		prompt("Prev Value of H")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LI,DBF_DOUBLE) {
		prompt("Prev Value of I")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LJ,DBF_DOUBLE) {
		prompt("Prev Value of J")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LK,DBF_DOUBLE) {
		prompt("Prev Value of K")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LL,DBF_DOUBLE) {
		prompt("Prev Value of L")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LM,DBF_DOUBLE) {
		prompt("Prev Value of M")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LN,DBF_DOUBLE) {
		prompt("Prev Value of N")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LO,DBF_DOUBLE) {
		prompt("Prev Value of O")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LP,DBF_DOUBLE) {
		prompt("Prev Value of P")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LQ,DBF_DOUBLE) {
		prompt("Prev Value of Q")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LR,DBF_DOUBLE) {
		prompt("Prev Value of R")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LS,DBF_DOUBLE) {
		prompt("Prev Value of S")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LT,DBF_DOUBLE) {
		prompt("Prev Value of T")
		special(SPC_NOMOD)
		interest(3)
	}
	field(LU,DBF_DOUBLE) {
		prompt("Prev Value of U")
		special(SPC_NOMOD)
		interest(3)
	}
	field(POVL,DBF_DOUBLE) {
		prompt("Prev Value of OVAL")
		asl(ASL0)
	}
	field(LALM,DBF_DOUBLE) {
		prompt("Last Value Alarmed")
		special(SPC_NOMOD)
		interest(3)
	}
	field(ALST,DBF_DOUBLE) {
		prompt("Last Value Archived")
		special(SPC_NOMOD)
		interest(3)
	}
	field(MLST,DBF_DOUBLE) {
		prompt("Last Val Monitored")
		special(SPC_NOMOD)
		interest(3)
	}
	%#include "postfix.h"
	field(RPCL,DBF_NOACCESS) {
		prompt("Reverse Polish Calc")
		special(SPC_NOMOD)
		interest(4)
		extra("char	rpcl[INFIX_TO_POSTFIX_SIZE(160)]")
	}
	field(ORPC,DBF_NOACCESS) {
		prompt("Reverse Polish OCalc")
		special(SPC_NOMOD)
		interest(4)
		extra("char	orpc[INFIX_TO_POSTFIX_SIZE(160)]")
	}

=head2 Record Support

=head3 Record Support Routines

=head2 C<init_record>

For each constant input link, the corresponding value field is initialized
with the constant value if the input link is CONSTANT or a channel access
link is created if the input link is PV_LINK.

A routine postfix is called to convert the infix expression in CALC and
OCAL to Reverse Polish Notation. The result is stored in RPCL and ORPC,
respectively.

=head2 C<process>

See next section.

=head2 C<special>

This is called if CALC or OCAL is changed. C<special> calls postfix.

=head2 C<get_units>

Retrieves EGU.

=head2 C<get_precision>

Retrieves PREC.

=head2 C<get_graphic_double>

Sets the upper display and lower display limits for a field. If the field
is VAL, HIHI, HIGH, LOW, or LOLO, the limits are set to HOPR and LOPR, else
if the field has upper and lower limits defined they will be used, else the
upper and lower maximum values for the field type will be used.

=head2 C<get_control_double>

Sets the upper control and lower control limits for a field. If the VAL,
HIHI, HIGH, LOW, or LOLO, the limits are set to HOPR and LOPR, else if the
field has upper and lower limits defined they will be used, else the upper
and lower maximum values for the field will be used.

=head2 C<get_alarm_double>

Sets the following values:

=over

upper_alarm_limit = HIHI

upper_warning_limit = HIGH

lower warning_limit = LOW

lower_alarm_limit = LOLO

=back

=head3 Record Processing

=head2 C<process()>

The C<process()> routine implements the following algorithm:

=over

=item 1.

Fetch all arguments.

=item 2.

Call routine C<calcPerform()>, which calculates VAL from the prefix version
of the expression given in CALC. If C<calcPerform()> returns success, UDF
is set to FALSE.

=item 3.

Check alarms. This routine checks to see if the new VAL causes the alarm
status and severity to change. If so, NSEV, NSTA and LALM are set. If also
honors the alarm hysteresis factor (HYST). Thus the value must change by at
least HYST before the alarm status and severity changes.

=item 4.

Determine if the Output Execution Option (OOPT) is met. If met, either
execute the output link (and output event) immediately (if ODLY = 0), or
schedule a callback after the specified interval. See the explanation for
the C<execOutput()> routine below.

=item 5.

Check to see if monitors should be invoked.

=over

=item *
Alarm monitors are invoked if the alarm status or severity has changed.

=item *
Archive and value change monitors are invoked if ADEL and MDEL conditions
are met.

=item *
Monitors for A-U are checked whenever other monitors are invoked.

=item *
NSEV and NSTA are reset to 0

=back

=item 6.

If no output delay was specified, scan forward link if necessary, set PACT
FALSE, and return.

=back

=head2 C<execOutput()>

=over

=item 1.

If DOPT field specifies the use of OCAL, call the routine C<calcPerform()>
for the postfix version of the expression in OCAL. Otherwise, use VAL.

=item 2.

If the Alarm Severity is INVALID, follow the option as designated by the
field IVOA.

=item 3.

The Alarm Severity is not INVALID or IVOA specifies "Continue Normally",
put the value of OVAL to the OUT link and post the event named in OEVT (if
not empty).

=item 4.

If an output delay was implemented, process the forward link.

=back

=cut
}

variable(calcoutODLYprecision, int)
variable(calcoutODLYlimit, double)
